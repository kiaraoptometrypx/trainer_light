<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1=" />

<title>Fan Chart with Fogging & CYL Blur</title>
<style>
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 0;
    font-family: Arial;
    font-size: 15px;
    color: #404040;
    height: 100vh;
    justify-content: center;
    background: lightgrey;
  }

  #header {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 20px;
    margin-bottom: 10px;
  }

  #container {
    display: flex;
    align-items: center;
    gap: 20px;
  }

  #left-controls, #right-controls {
    display: flex;
    flex-direction: column;
    gap: 20px;
  }

  #cylVal { font-weight: bold; margin-left:5px; }

  button {
    border: 1px solid grey;
    font-size: 12px;
    padding: 2px;
    height: 75px;
    width: 75px;
    border-radius: 10px;
    color: #404040;
    margin-top: 5px;
    margin-bottom: 5px;
    user-select:none;
    font-weight:600;

  }

  .smallbtn {
    border: 1px solid grey;
    font-size: 15px;
    padding: 2px;
    height: 25px;
    width: 100px;
    border-radius: 10px;
    color: #404040;
    margin-top: 5px;
    margin-bottom: 5px;
    user-select:none;
  }

#fan-wrapper {
  display: inline-flex;   /* key */
  width: 520px;
  height: 450px;
  background-image: url("https://raw.githubusercontent.com/kiaraoptometrypx/trainer_light/main/FCBG.jpg");
  background-size: cover;       
  background-position: center;  
  background-repeat: no-repeat;
  position: relative;
  display: flex;
  justify-content: center;     
  align-items: center;         
  overflow: hidden;            
  border-radius: 50px;          
}


#fan-container {
  width: 480px;       /* fan smaller than wrapper */
  height: 480px;
  background: transparent;
  display: block;
  margin-top: 35px;   
  margin-left: 3px;
}

#page-wrapper {
  display: inline-flex;   /* key */
  justify-content: center;    
  max-width: 100%;
  flex-direction: column;
  align-items: center;
}

.bg-dc {
  width: 520px;
  height: 350px;
  background-image: url("https://raw.githubusercontent.com/kiaraoptometrypx/trainer_light/main/DCBG.jpg");
  background-size: 120% auto;  /* zoom in 20% */
  background-position: center calc(50% - 20%) ; 
  background-repeat: no-repeat;
  margin: 0 auto;
  border-radius: 50px;
}

#dc-container{
  display: inline-flex;   /* key */
  align-items:center;
  gap:20px;
  justify-content: center;    
}

.dc-controls{
  display:flex;
  flex-direction:column;
  gap:20px;
}


</style>
</head>

<body>

<div style="max-width:100%; margin-top:1000px">

<table>


<tr>
<td align="center" style="text-align:center;">

<div style="text-align:center; margin-top:500px; margin-bottom:100px">
<span style="font-size:25px"><b>Kiara Optometry Refraction Helper</b></span>


<div style="height:60px"></div>



<span><b>Which type of duochrome vision do you see?</b></span><br>


<div style="margin-top:20px" id="header">
  <span style="font-size:25px"><b>SPH Value Correction <span id="dcHint">0.00</span></span>

</div>

<div style="height:20px"></div>

<div id="dc-container">
  
  <!-- Left controls -->
  <div class="dc-controls">
    <button class="button" onclick="selectDC(1)"><b><span style="color:darkred"> Red 1</span></b></button>
    <button class="button" onclick="selectDC(2)"><b><span style="color:darkred"> Red 2</span></b></button>
  </div>

  <!-- Center image -->
  <div class="bg-dc"></div>

  <!-- Right controls -->
  <div class="dc-controls">
    <button class="button" onclick="selectDC(3)"><b><span style="color:darkblue"> Blue 3</span></b></button>
    <button class="button" onclick="selectDC(4)"><b><span style="color:darkblue"> Blue 4</span></b></button>
  </div>

</div>




</div>

</td></tr>




<tr>
<td align="center" style="text-align:center;">

  <div id="page-wrapper">



<span><b>Adjust the rotation and line darkness to match what you see.</b></span>

<div style="margin-top:20px" id="header">
  <span style="font-size:25px"><b>CYL Value Correction<span style="color:darkred" id="cylVal">0.00</span></b></span>
</div>
<div style="height:20px"></div>


<div id="container">
  <div id="left-controls">


    <div>
      <b>Line</b><br>
      <button onclick="changeCyl(-0.25)">Lighter</button>
    </div>
    <div>
      <b>Rotate</b><br>
      <button onclick="rotateFan(-45)"><<<</button><br>
      <button onclick="rotateFan(-15)"><<</button><br>
      <button onclick="rotateFan(-7.5)"><</button>
    </div>
  </div>

  <!-- Fan wrapper -->
  <div id="fan-wrapper">
    <canvas id="fan-container"></canvas>
  </div>

  <div id="right-controls">

<div style="display:none">
<b>All Lines</b><br>
  <button id="fogBtn" onclick="toggleFogging()">Lighter</button>
</div>

    <div>
      <b>Line</b><br>
      <button onclick="changeCyl(0.25)">Darker</button>
    </div>
    <div>
      <b>Rotate</b><br>
      <button onclick="rotateFan(45)">>>></button><br>
      <button onclick="rotateFan(15)">>></button><br>
      <button onclick="rotateFan(7.5)">></button>
    </div>
  </div>
</div>

</div>

</td></tr>

<tr style="height:100px"><td>
</td></tr>

<tr><td>

<div style="text-align:center; margin-bottom:15px;">
  <span><b>Astigmatism Defect Simulation</b></span><br>

<div style="margin-top:20px" id="header">
  <span style="font-size:25px"><b>CYL Value Correction <span style="color:darkred"> - </span> <span style="color:darkred" id="astigCylVal">0.00</span> <span style="color:darkred"> x </span> <span style="color:darkred" id="astigAxisVal">180</span></b></span>
</div>




<div id="astig-container" style="display:flex; justify-content:center; align-items:center; gap:20px;">

  <!-- Left Controls: INCREASE (+) -->
  <div style="display:flex; flex-direction:column; gap:5px; align-items:center;">
    <b>CYL</b>
    <button onclick="adjCyl(-0.25)" class="btn-plus">+0.25</button>

    <br><b>AXIS</b>
    <button onclick="adjAxis(45)" class="btn-plus">+45°</button>
    <button onclick="adjAxis(5)" class="btn-plus">+5°</button>

    <br><b>LETTER SIZE</b>
    <button onclick="adjustLetterSize(50)" class="btn-plus">A+</button>
  </div>

  <!-- Center Canvas -->
  <canvas id="astigCanvas" width="500" height="500"
    style="background:#fff; border:1px solid #ccc; border-radius:50px;">
  </canvas>

  <!-- Right Controls: DECREASE (−) -->
  <div style="display:flex; flex-direction:column; gap:5px; align-items:center;">
    <b>CYL</b>
    <button onclick="adjCyl(0.25)" class="btn-minus">−0.25</button>

    <br><b>AXIS</b>
    <button onclick="adjAxis(-45)" class="btn-plus">-45°</button>
    <button onclick="adjAxis(-5)" class="btn-minus">−5°</button>

    <br><b>LETTER SIZE</b>
    <button onclick="adjustLetterSize(-50)" class="btn-minus">A−</button>
  </div>

</div>


<script>
const aCanvas = document.getElementById("astigCanvas");
const aCtx = aCanvas.getContext("2d");

let cyl = 0.00;
let axis = 180;
let letterSize = 250; // starting font size

const cylDisplay = document.getElementById("astigCylVal");
const axisDisplay = document.getElementById("astigAxisVal");

/* ===== Directional Blur ===== */
function directionalBlur(imageData, angle, strength) {
    const w = imageData.width;
    const h = imageData.height;
    const src = imageData.data;
    const output = aCtx.createImageData(w, h);
    const dst = output.data;
    const dx = Math.cos(angle);
    const dy = Math.sin(angle);
const radius = Math.floor(strength);
if (radius <= 0) return imageData;

    for (let y=0;y<h;y++){
        for(let x=0;x<w;x++){
            let r=0,g=0,b=0,a=0,count=0;
            for(let i=-radius;i<=radius;i++){
                let sx = Math.round(x+dx*i);
                let sy = Math.round(y+dy*i);
                if(sx>=0 && sx<w && sy>=0 && sy<h){
                    let idx = (sy*w+sx)*4;
                    r+=src[idx]; g+=src[idx+1]; b+=src[idx+2]; a+=src[idx+3];
                    count++;
                }
            }
            let di = (y*w+x)*4;
            dst[di]=r/count; dst[di+1]=g/count; dst[di+2]=b/count; dst[di+3]=a/count;
        }
    }
    return output;
}

/* ===== Text Wrapping ===== */
function wrapText(text, x, y, maxWidth, lineHeight){
    const words = text.split(" ");
    let line = "";
    for(let n=0;n<words.length;n++){
        let testLine = line + words[n] + " ";
        let metrics = aCtx.measureText(testLine);
        if(metrics.width>maxWidth && n>0){
            aCtx.fillText(line,x,y);
            line=words[n]+" ";
            y+=lineHeight;
        } else line=testLine;
    }
    aCtx.fillText(line,x,y);
}

/* ===== Controls ===== */
function adjCyl(step){ cyl = Math.max(0, Math.min(3, cyl+step)); drawAstig(); }
function adjAxis(step){ axis=(axis+step+180)%180; drawAstig(); }
function adjustLetterSize(delta){ letterSize=Math.max(20,letterSize+delta); drawAstig(); }

/* ===== Main Draw ===== */
function drawAstig(){
    aCtx.clearRect(0,0,aCanvas.width,aCanvas.height);

    // Paragraph (scales with letter size)
    const para = "Astigmatism occurs when the eye is uneven, causing light to defocus for some area.";
    const paraSize = Math.max(15, Math.floor(letterSize/5));
    aCtx.font = `${paraSize}px Arial`;
    aCtx.fillStyle="black";
    aCtx.textAlign="center";
    aCtx.textBaseline="top";
    wrapText(para, aCanvas.width/2, 50, 450, paraSize+5);

    // Apply blur
    const imgData = aCtx.getImageData(0,0,aCanvas.width,aCanvas.height);
    const blurred = directionalBlur(imgData,(axis+90)*Math.PI/180,cyl*5);
    aCtx.putImageData(blurred,0,0);

    // Update display
cylDisplay.textContent = (cyl).toFixed(2);
    axisDisplay.textContent = axis;
}

drawAstig();
</script>




</td></tr>

<tr><td>

<div style="text-align:center; margin-top:40px;">

<label><b>Balance</b></label><br>
<input type="number" id="balanceInput" step="0.25" value="-2.00">
<button onclick="updateBar()">Update Scale</button>

<br><br>

<label><b>Current</b></label><br>
<input type="number" id="currentInput" step="0.25" value="-2.00">
<button onclick="updateArrow()">Show Arrow</button>

<div id="scaleContainer" style="width:70%; margin:20px auto; position:relative; height:160px; padding:0 20px;">

    <div id="bar" style="height:20px; display:flex; margin-top:50px;">
        <div style="flex:1; background:red;"></div>
        <div style="flex:1; background:blue;"></div>
    </div>

    <div id="scaleMarks" style="display:flex; justify-content:space-between; height:60px; align-items:flex-start; margin-top:4px;"></div>

    <div id="arrowContainer" style="display:flex; justify-content:space-between; position:absolute; bottom:0; left:20px; right:20px; height:90px; pointer-events:none;"></div>

</div>
</div>

<script>
let numbers = [];

// Snap input to nearest 0.25
function snapInput(input) {
    let val = parseFloat(input.value);
    if (isNaN(val)) val = 0;
    val = Math.round(val * 4) / 4;
    input.value = val.toFixed(2);
}

// Generate scale with balance in middle and Outside ticks
function updateBar() {
    snapInput(document.getElementById("balanceInput"));
    let balance = parseFloat(document.getElementById("balanceInput").value);

    const step = 0.25;
    const leftEnd = balance + 1;  // less minus
    const rightEnd = balance - 1; // more minus

    numbers = [];

    // Left side
    for (let val = leftEnd; val > balance; val -= step) numbers.push(val.toFixed(2));

    // Center (balance)
    numbers.push(balance.toFixed(2));

    // Right side
    for (let val = balance - step; val >= rightEnd; val -= step) numbers.push(val.toFixed(2));

    // Add Outside ticks
    numbers.unshift("Outside"); // leftmost
    numbers.push("Outside");    // rightmost

    const scaleDiv = document.getElementById("scaleMarks");
    scaleDiv.innerHTML = '';

    numbers.forEach((n, idx) => {
        const midIndex = numbers.indexOf(balance.toFixed(2));
        const color = idx < midIndex ? 'red' : (idx > midIndex ? 'blue' : 'black');

        const tickContainer = document.createElement('div');
        tickContainer.style.flex = '1';
        tickContainer.style.display = 'flex';
        tickContainer.style.flexDirection = 'column';
        tickContainer.style.alignItems = 'center';

        const tick = document.createElement('div');
        tick.style.width = '2px';
        tick.style.height = (idx === midIndex ? '20px' : '10px');
        tick.style.backgroundColor = color;

        const numLabel = document.createElement('div');
        numLabel.innerText = n;
        numLabel.style.marginTop = '4px';
        numLabel.style.fontFamily = 'monospace';
        numLabel.style.fontSize = '12px';

        tickContainer.appendChild(tick);
        tickContainer.appendChild(numLabel);
        scaleDiv.appendChild(tickContainer);
    });

    document.getElementById("arrowContainer").innerHTML = '';
}

// Update arrow below ticks, snap to Outside if out of scale
function updateArrow() {
    snapInput(document.getElementById("currentInput"));
    const current = parseFloat(document.getElementById("currentInput").value);
    if (isNaN(current) || numbers.length === 0) return;

    const arrowContainer = document.getElementById("arrowContainer");
    arrowContainer.innerHTML = '';

    const totalTicks = numbers.length;

    // Find numeric indexes (ignore Outside labels)
    let numericIndexes = numbers.map((v, i) => isNaN(parseFloat(v)) ? null : i).filter(v=>v!==null);

    // Determine closest tick
    let relativeIndex;
    if (current > parseFloat(numbers[numericIndexes[0]])) relativeIndex = 0; // left Outside
    else if (current < parseFloat(numbers[numericIndexes[numericIndexes.length-1]])) relativeIndex = numbers.length-1; // right Outside
    else {
        // Snap to nearest numeric tick
        relativeIndex = numericIndexes.reduce((prev, curr) => {
            return Math.abs(parseFloat(numbers[curr]) - current) < Math.abs(parseFloat(numbers[prev]) - current) ? curr : prev;
        }, numericIndexes[0]);
    }

    for (let i = 0; i < totalTicks; i++) {
        const flexItem = document.createElement('div');
        flexItem.style.flex = '1';
        flexItem.style.position = 'relative';

        if (i === relativeIndex) {
            const arrow = document.createElement('div');
            arrow.style.width = '0';
            arrow.style.height = '0';
            arrow.style.borderLeft = '6px solid transparent';
            arrow.style.borderRight = '6px solid transparent';
            arrow.style.borderBottom = '12px solid black';
            arrow.style.position = 'absolute';
            arrow.style.top = '0';
            arrow.style.left = '50%';
            arrow.style.transform = 'translateX(-50%)';
            flexItem.appendChild(arrow);

            const label = document.createElement('div');
            label.style.position = 'absolute';
            label.style.top = '14px';
            label.style.left = '50%';
            label.style.transform = 'translateX(-50%)';
            label.style.fontFamily = 'monospace';
            label.style.fontSize = '12px';
            label.innerText = current.toFixed(2) + " (Current)";
            flexItem.appendChild(label);
        }

        arrowContainer.appendChild(flexItem);
    }
}

// Initialize
updateBar();
</script>




  
</td></tr>





<tr style="height:500px"><td>
</td></tr>

</table>


</div>





<script>
function selectDC(val){
  const dcHint = document.getElementById("dcHint");

  switch(val){
    case 1:
      dcHint.textContent = "- 0.50 (Undercorrected)";
      dcHint.style.color = "darkred";
      break;
    case 2:
      dcHint.textContent = "- 0.25 (Optimum Near)";
      dcHint.style.color = "darkred";
      break;
    case 3:
      dcHint.textContent = "+ 0.25 (Optimum Far)";
      dcHint.style.color = "darkblue";
      break;
    case 4:
      dcHint.textContent = "+ 0.50 (Overcorrected)";
      dcHint.style.color = "darkblue";
      break;
  }
}
</script>











<script>
const canvas = document.getElementById('fan-container');
const ctx = canvas.getContext('2d');

/* ===== State ===== */
let cylBlur = 0.00;
let fogOn = false;
let fogStrength = 0.25;
let angle = 0;

const cylVal = document.getElementById('cylVal');
const fogBtn = document.getElementById('fogBtn');

/* ===== Display ===== */
function updateCylDisplay() {
  let axis = angle % 180;
  if (axis === 0) axis = 180;

  // Mapping: every 15° step
  const clockMap = {
    0: "9 ‑ 3",
    15: "9:30 ‑ 3:30",
    30: "10 ‑ 4",
    45: "10:30 ‑ 4:30",
    60: "11 ‑ 5",
    75: "11:30 ‑ 5:30",
    90: "12 ‑ 6",
    105: "12:30 ‑ 6:30",
    120: "1 ‑ 7",
    135: "1:30 ‑ 7:30",
    150: "2 ‑ 8",
    165: "2:30 ‑ 8:30",
    180: "9 ‑ 3"
  };

  // Find nearest step
  let step = Math.round(axis / 15) * 15;
  if(step > 180) step = 180;

  const description = clockMap[step];

  cylVal.innerHTML = `
    - ${cylBlur.toFixed(2)} × ${axis.toString().padStart(3,'0')} (${description} deficit)
  `;
}

updateCylDisplay();



/* ===== Controls ===== */
function toggleFogging() {
  fogOn = !fogOn;
  fogBtn.textContent = fogOn ? 'Lighter' : 'Darker';
  drawFan();
}

function changeCyl(delta) {
  cylBlur = Math.max(0, +(cylBlur + delta).toFixed(2));
  updateCylDisplay();
  drawFan();
}

function rotateFan(delta){
  angle = (angle + delta) % 180;
  if (angle < 0) angle += 180; // ensure positive
  updateCylDisplay();
  drawFan();
}

function setupCanvas(canvas, ctx) {
  const dpr = window.devicePixelRatio || 1;

  const rect = canvas.getBoundingClientRect();
  canvas.width  = rect.width * dpr;
  canvas.height = rect.height * dpr;

  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}


function drawFan() {
const rect = canvas.getBoundingClientRect();
const cw = rect.width;
const ch = rect.height;
const cx = cw / 2;
const cy = ch / 2;

  const outerR = cw * 0.29;
  const innerR = cw * 0.075;
  const lineLen = cw * 0.25;
  const dotOffset = cw * 0.275;
  const fanAngles = [0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165];
  const maxBlur = 2.5; // max total blur
  const totalShades = 12; // number of incremental layers
  
  ctx.clearRect(0, 0, cw, ch);

  /* Outer white circle */
  ctx.beginPath();
  ctx.arc(cx, cy, outerR, 0, Math.PI * 2);
  ctx.fillStyle = 'white';
  ctx.fill();

  ctx.save();
  ctx.translate(cx, cy);

  function diff180(a, b) {
    let d = (a - b + 180) % 180;
    return Math.min(d, 180 - d);
  }

  fanAngles.forEach(a => {
    const rel = diff180(a, angle);
    const effectiveRel = Math.min(rel, 90);
    const basePower = 1;          // shape at low cyl
    const cylInfluence = 0.35;       // how much cyl affects curve

const dynamicPower = basePower - (cylBlur * cylInfluence);
const t = effectiveRel / 90;

const rawBlur = Math.min(
  Math.pow(t, Math.max(0.2, dynamicPower)) * (cylBlur * 2.5)
  + (fogOn ? fogStrength : 0),
  maxBlur
);

const NONLINEAR_EXP = 1;  // <1 = compress high values, >1 = exaggerate
const shadeOffset = Math.pow(rawBlur, NONLINEAR_EXP) / totalShades * cw * 0.01;


for (let i = 0; i < totalShades; i++) {
  ctx.save();
  ctx.rotate(a * Math.PI / 180);

  const offset = (i - (totalShades - 1) / 2) * shadeOffset;

  // Spread fraction based on index, not offset
  const spreadFraction = Math.abs(i - (totalShades - 1) / 2) / ((totalShades - 1) / 2);

  // line width decreases from center to edges
  const maxLineWidth = 2.0;
  const minLineWidth = 3.0;
  ctx.lineWidth = maxLineWidth - spreadFraction * (maxLineWidth - minLineWidth);

  const baseColor = 0;
  const maxColor = 160;
  const val = Math.round(baseColor + shadeOffset * (maxColor - baseColor));
  ctx.strokeStyle = `rgba(${val},${val},${val},${1.1 / totalShades})`;



  ctx.beginPath();
  ctx.moveTo(offset, -lineLen);
  ctx.lineTo(offset, lineLen);
  ctx.stroke();

  ctx.restore();
}


  });

  ctx.restore();

  /* Axis dots */
  [0, 180].forEach(a => {
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate((a + angle) * Math.PI / 180);

    ctx.beginPath();
    ctx.arc(0, -dotOffset, 4, 0, Math.PI * 2);
    ctx.fillStyle = 'darkred';
    ctx.fill();

    ctx.restore();
  });

  /* Center white circle */
  ctx.beginPath();
  ctx.arc(cx, cy, innerR, 0, Math.PI * 2);
  ctx.fillStyle = 'white';
  ctx.fill();
}

setupCanvas(canvas, ctx);
drawFan();

</script>
































</body>
</html>
