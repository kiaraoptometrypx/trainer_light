<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Fanchart & Duochrome Trainer (Light)</title>
<style>
  body { font-family: system-ui, sans-serif; background:#fff; text-align:center; margin:20px; }
  #currentRx { font-weight:600; font-size:16px; margin-bottom:10px; }

  .card{ background:#fff; border-radius:10px; padding:20px 10px;
    box-shadow:0 0 10px rgba(0,0,0,.25); display:inline-block; border:1px solid #bbb; margin:8px 0 14px; }
  .row input[type=number]{ width:70px; text-align:center; }
  .row b{ display:inline-block; margin-bottom:6px; }
  button{ margin:5px; padding:5px 10px; cursor:pointer; }

  /* Duochrome */
  .duochrome{ display:flex; justify-content:center; align-items:center; width:300px; height:300px; margin:20px auto; position:relative; overflow:hidden; }
  .duo-side{ position:relative; width:150px; height:300px; display:flex; align-items:center; justify-content:center; overflow:clip; contain:paint; isolation:isolate; }
  @supports not (overflow: clip) { .duo-side { overflow:hidden; } }
  #redSide  { clip-path: inset(0 0 0 10px); }
  #blueSide { clip-path: inset(0 10px 0 0); }
  .duo-side img.base{ width:150px; height:300px; object-fit:cover; display:block; will-change:filter; }
  .duo-side img.overlay{ display:none; position:absolute; left:0; top:0; width:150px; height:300px; object-fit:cover; pointer-events:none; will-change:transform, filter, opacity; backface-visibility:hidden; transform: translate3d(0,0,0); }

  /* Fan chart */
  .outer-circle{ width:250px; height:250px; border-radius:50%; border:none; overflow:hidden; display:flex; align-items:center; justify-content:center; margin:40px auto; transform-origin:center; }
  .circular-img img{ width:300px; height:auto; object-fit:cover; object-position:center; transform-origin:center; }

  /* Layout */
  #stage { display:flex; gap:50px; align-items:center; justify-content:center; flex-wrap:wrap; }
  .duochrome, .outer-circle { margin:12px 0; }

  .rx-input { width:120px; font-size:12px; text-align:center; padding:6px; border-radius:6px; border:1px solid #ccc; margin-bottom:5px; }
  .btn-plus, .btn-minus { font-size:14px; border:1px solid #000; padding:6px 10px; border-radius:6px; cursor:pointer; color:#fff; transition:opacity .2s; margin:2px; }
  .btn-plus { background:#212121; } .btn-minus{ background:#d9534f; }
  .btn-plus:hover, .btn-minus:hover { opacity:.85; }
  .btn-group button { font-size:12px; padding:5px 5px; margin:5px; border:1px solid #000; border-radius:10px; cursor:pointer; background:#dcdcdc; color:#000; min-width:160px; }
  .btn-group button:hover { background:#c8c8c8; }

  #targetPanel input{ width:60px; font-size:12px; padding:5px; text-align:center; margin:2px 2px; border-radius:5px; }
</style>
</head>
<body>

<div style="height:10px;"></div>
<div id="currentRx">FANCHART & DUOCHROME TRAINER (LIGHT)</div>
<div><span>Go to Algorithm Refraction here: 
<a href="https://kiaraoptometrypx.github.io/RX-calculator/" target="_blank" rel="noopener">RX-calculator</a>
</span></div>
<div style="height:10px"></div>

	

<!-- Controls -->
<div id="controls" class="card" style="font-size:15px; width:600px">
  Your challenge is to find the RX that makes everything clear again!
  <div style="height:16px"></div>


  <div class="row btn-group" style="display:flex; justify-content:center; gap:10px;">
    <button style="background:#fffdf0; border:1px solid grey; width:500px;" id="randBtn">New Test</button>
  </div>

  <!-- Show/Set Answer -->
  <div id="targetPanel" style="border:none; display:none; justify-content:center; width:100%;">
    <b>SPH</b> <input style="width:100px" type="number" id="tSph" step="0.25" value="-1.00">
    <b>CYL</b> <input style="width:100px" type="number" id="tCyl" step="0.25" value="-1.00">
    <b>AXIS</b> <input style="width:100px" type="number" id="tAxis" step="5"   value="180">
    <div style="height:10px"></div>
  </div>

  <!-- Participant Inputs -->
  <div style="display:flex; justify-content:center; gap:50px; flex-wrap:wrap; align-items:flex-start; margin-top:10px;">
    <!-- SPH -->
    <div style="text-align:center;">
      <label><b>SPH</b></label><br>
      <input type="number" id="sph" step="0.25" value="0.00" class="rx-input"><br>
      <div>
        <button onclick="adj('sph',-0.25)" class="btn-minus">−0.25</button>
        <button onclick="adj('sph', 0.25)" class="btn-plus">+0.25</button><br>
        <button onclick="adj('sph',-0.50)" class="btn-minus">−0.50</button>
        <button onclick="adj('sph', 0.50)" class="btn-plus">+0.50</button><br>
        <button onclick="adj('sph',-1.00)" class="btn-minus">−1.00</button>
        <button onclick="adj('sph', 1.00)" class="btn-plus">+1.00</button>
      </div>
    </div>

    <!-- CYL -->
    <div style="text-align:center;">
      <label><b>CYL</b></label><br>
      <input type="number" id="cyl" step="0.25" value="0.00" class="rx-input"><br>
      <div>
        <button onclick="adj('cyl',-0.25)" class="btn-minus">−0.25</button>
        <button onclick="adj('cyl', 0.25)" class="btn-plus">+0.25</button><br>
        <button onclick="adj('cyl',-0.50)" class="btn-minus">−0.50</button>
        <button onclick="adj('cyl', 0.50)" class="btn-plus">+0.50</button><br>
        <button onclick="adj('cyl',-1.00)" class="btn-minus">−1.00</button>
        <button onclick="adj('cyl', 1.00)" class="btn-plus">+1.00</button>
      </div>
    </div>

    <!-- AXIS -->
    <div style="text-align:center;">
      <label><b>AXIS</b></label><br>
      <input type="number" id="axis" step="1" value="180" class="rx-input"><br>
      <div>
        <button onclick="adj('axis', -1)"  class="btn-minus">−1</button>
        <button onclick="adj('axis',  1)"  class="btn-plus">+1</button><br>        
	<button onclick="adj('axis', -5)"  class="btn-minus">−5</button>
        <button onclick="adj('axis',  5)"  class="btn-plus">+5</button><br>
        <button onclick="adj('axis',-20)"  class="btn-minus">−20</button>
        <button onclick="adj('axis', 20)"  class="btn-plus">+20</button>
      </div>
    </div>
  </div>

  <div style="height:20px"></div>


  <!-- Main Buttons -->
  <div class="row btn-group">
    <button style="width:500px" id="resetBtn">Reset Rx to 0</button>
  </div>
  <div class="row btn-group">
    <button style="background:pink; border:1px solid black; width:245px;" id="formToggleBtn">Convert Cyl</button>
    <button style="background:pink; border:1px solid black; width:245px;" id="targetToggleBtn">Show Answer</button>
  </div>

</div>
<div style="height:20px"></div>

<!-- Stage -->
<div id="stage">
  <!-- Fan Chart -->
  <div id="stack" style="position:relative; width:400px; margin:0 0 20px 0;">
    <img class="bg" src="https://raw.githubusercontent.com/kiaraoptometrypx/Trainer/main/FC_DIRECTIONS.png" alt="" style="width:100%; display:block;" />
    <div class="overlay" style="position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none;">
      <div class="overlay-stage">
        <div class="outer-circle" id="outerCircle" style="width:100%; aspect-ratio:1/1; border-radius:9999px; overflow:hidden;">
          <div class="circular-img" style="width:100%; height:100%;">
            <img id="fanChart" src="https://raw.githubusercontent.com/kiaraoptometrypx/Trainer/main/C025.png" alt="" style="width:100%; height:100%; object-fit:cover;" />
          </div>
        </div>
      </div>
    </div>
  </div>

 <!-- Duochrome (button above) -->
<div class="duo-wrap">
  <div class="duochrome">
    <div class="duo-side" id="redSide">
      <img class="base" id="redImg"  src="https://raw.githubusercontent.com/kiaraoptometrypx/Trainer/main/RED_2.png"  alt="">
      <img class="overlay" id="redOv"  alt="">
    </div>
    <div class="duo-side" id="blueSide">
      <img class="base" id="blueImg" src="https://raw.githubusercontent.com/kiaraoptometrypx/Trainer/main/BLUE_2.png" alt="">
      <img class="overlay" id="blueOv" alt="">
    </div>
  </div>
  <div class="row btn-group">

  <button id="sizeBtn" class="size-btn" style="width:270px">Change Letter Size</button>
</div>
</div>


<!-- Quick adjust -->
<script>
function adj(type, step){
  const el = document.getElementById(type);
  let v = parseFloat(el.value)||0;
  v += step;
  if(type==='axis'){
    if(v < 1) v = 180;
    if(v > 180) v = 1;
    el.value = Math.round(v);
  } else {
    el.value = v.toFixed(2);
  }
  el.dispatchEvent(new Event('input'));
}
</script>

<script>
/* ===== Tunables & State ===== */
const PX_PER_D = 2, K_BLUR_PER_D = 2.0, EXTRA_ASTIG_BLUR_PER_D = 0.40, OVERLAY_ALPHA = 0.60, AXIS_STEP = 5;
const T_SPH_MIN = -7.00, T_SPH_MAX = +4.00, T_CYL_MIN = -4.00, T_CYL_MAX = 0.00; // global clamps; actual test range set in New Test
const FC_BLUR_GAIN = 0.50;

const redImg = document.getElementById('redImg');
const blueImg = document.getElementById('blueImg');
const redOv  = document.getElementById('redOv');
const blueOv = document.getElementById('blueOv');
const fanImg = document.getElementById('fanChart');
const outer  = document.getElementById('outerCircle');

const sphInput = document.getElementById('sph');
const cylInput = document.getElementById('cyl');
const axisInput= document.getElementById('axis');

const randBtn = document.getElementById('randBtn');
const sizeBtn = document.getElementById('sizeBtn');
const targetToggleBtn = document.getElementById('targetToggleBtn');
const formToggleBtn = document.getElementById('formToggleBtn');
const resetBtn = document.getElementById('resetBtn');

const targetPanel = document.getElementById('targetPanel');
const tSph = document.getElementById('tSph');
const tCyl = document.getElementById('tCyl');
const tAxis= document.getElementById('tAxis');

let letterSize = 2;
let TARGET = { S: -1.00, C: -1.00, A: 180 };
let TRUE   = { sph: 0, cyl: 0, axis: 180, se: 0 };

/* Preload + safe overlay src */
const SIZES = [1,2,3], cache = {};
(function preloadAll(){
  SIZES.forEach(sz=>{
    ["RED","BLUE"].forEach(col=>{
      const url = `https://raw.githubusercontent.com/kiaraoptometrypx/Trainer/main/${col}_${sz}.png`;
      const im = new Image(); im.decoding = "async"; im.src = url;
      cache[`${col}_${sz}`] = im;
    });
  });
})();
async function applyLetterImages(){
  const rKey = `RED_${letterSize}`, bKey = `BLUE_${letterSize}`;
  await Promise.all([ cache[rKey]?.decode?.().catch(()=>{}), cache[bKey]?.decode?.().catch(()=>{}) ]);
  redImg.src  = cache[rKey].src;
  blueImg.src = cache[bKey].src;
  redOv.src   = cache[rKey].src;
  blueOv.src  = cache[bKey].src;
  redOv.style.display  = 'block';
  blueOv.style.display = 'block';
}

/* Helpers */
const quant05 = v => Math.round(v*2)/2;
function wrapAxis(val){
  const n = parseFloat(val);
  if (!Number.isFinite(n)) return 0;
  const raw = String(val).trim();
  let v = ((Math.round(n) % 180) + 180) % 180;
  return raw === "180" ? 180 : (v === 0 ? 1 : v);
}
function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

/* Minus-cyl normalize + target clamp */
function normalizeMinus(S, C, A){
  if (C > 0){ S = S + C; C = -C; A = (wrapAxis(A + 90)) || 180; }
  else A = wrapAxis(A);
  return { S, C, A };
}
function clampTarget(obj){
  let S = clamp((+obj.S || 0), T_SPH_MIN, T_SPH_MAX);
  let C = (+obj.C || 0); if (C > 0) C = -C; C = clamp(C, T_CYL_MIN, T_CYL_MAX);
  let A = wrapAxis(+obj.A || 180);
  return { S, C, A };
}

/* Power-vectors */
function toVec(S, C, Adeg){
  const rad2 = (2*Adeg) * Math.PI/180;
  const M  = S + C/2;
  const J0 = -(C/2) * Math.cos(rad2);
  const J45= -(C/2) * Math.sin(rad2);
  return {M,J0,J45};
}
function fromVec(M, J0, J45){
  const C = -2 * Math.hypot(J0, J45);
  let A = 0.5 * (Math.atan2(J45, J0) * 180/Math.PI);
  A = ((A % 180) + 180) % 180 || 180;
  const S = M - C/2;
  return {S, C, A};
}

function getParticipantMinus(){
  const S = parseFloat(sphInput.value)||0;
  const C = parseFloat(cylInput.value)||0;
  const A = wrapAxis(axisInput.value||0);
  return normalizeMinus(S, C, A);
}

/* Compute Over-Rx */
function recomputeOver(){
  const Pm = getParticipantMinus();
  const Tm = normalizeMinus(...Object.values(clampTarget(TARGET)));
  const t = toVec(Tm.S, Tm.C, Tm.A);
  const p = toVec(Pm.S, Pm.C, Pm.A);
  const d = { M: t.M - p.M, J0: t.J0 - p.J0, J45: t.J45 - p.J45 };
  const o = fromVec(d.M, d.J0, d.J45);
  TRUE.sph  = o.S; TRUE.cyl  = o.C; TRUE.axis = o.A; TRUE.se = d.M;
  updateViews();
}

/* Render */
function updateViews(){
  const cyl  = TRUE.cyl, axis = TRUE.axis, deltaSE = TRUE.se;
  const s = Math.abs(deltaSE), primary = s * K_BLUR_PER_D, secondary = (s >= 0.75) ? ((s - 0.5) * K_BLUR_PER_D) : 0;
  const fcBlur = quant05(primary * FC_BLUR_GAIN);

  let blurRed=0, blurBlue=0;
  if (deltaSE > 0){ blurRed = primary; blurBlue = secondary; }
  else if (deltaSE < 0){ blurBlue = primary; blurRed = secondary; }
  redImg.style.filter  = `blur(${quant05(blurRed)}px)`;
  blueImg.style.filter = `blur(${quant05(blurBlue)}px)`;

  const mag = Math.abs(cyl) * PX_PER_D;
  let ang = (axis % 180) * 2; ang -= 90;
  const rad = ang * Math.PI / 180;
  const shiftX = Math.round(Math.cos(rad) * mag);
  const shiftY = Math.round(Math.sin(rad) * mag);
  redOv.style.transform  = `translate(${shiftX}px, ${shiftY}px)`;
  blueOv.style.transform = `translate(${shiftX}px, ${shiftY}px)`;

  const extra = Math.abs(cyl) * EXTRA_ASTIG_BLUR_PER_D;
  redOv.style.filter  = `blur(${quant05(blurRed  + extra)}px)`;
  blueOv.style.filter = `blur(${quant05(blurBlue + extra)}px)`;
  redOv.style.opacity = blueOv.style.opacity = OVERLAY_ALPHA;

  const absC = Math.abs(cyl);
  let imgName = "C025.png";
  if      (absC <= 0.25) imgName="C025.png";
  else if (absC <= 0.50) imgName="C050.png";
  else if (absC <= 0.75) imgName="C075.png";
  else if (absC <= 1.00) imgName="C100.png";
  else                   imgName="C150.png";
  fanImg.src = `https://raw.githubusercontent.com/kiaraoptometrypx/Trainer/main/${imgName}`;
  fanImg.style.filter = `blur(${fcBlur}px)`;

  const axisFC = (axis + 90) % 180;
  const fcOffset = (deltaSE > 0) ? 90 : 0;
  outer.style.transform = `scaleX(-1) rotate(${-(axisFC + fcOffset)}deg)`;
}

/* ============ Inputs & UI ============ */
[sphInput, cylInput].forEach(el => el.addEventListener('input', recomputeOver));

axisInput.addEventListener('input', () => {
  axisInput.value = wrapAxis(axisInput.value || 0);
  recomputeOver();
});
axisInput.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowUp')   { e.preventDefault(); axisInput.value = wrapAxis((parseFloat(axisInput.value)||0) + AXIS_STEP); }
  if (e.key === 'ArrowDown') { e.preventDefault(); axisInput.value = wrapAxis((parseFloat(axisInput.value)||0) - AXIS_STEP); }
  recomputeOver();
});

/* Letter size toggle */
sizeBtn.addEventListener('click', async () => {
  letterSize = (letterSize % 3) + 1;
  await applyLetterImages();
  updateViews();
});

/* Show / Hide Answer */
targetToggleBtn.addEventListener('click', () => {
  const open = targetPanel.style.display !== 'none';
  targetPanel.style.display = open ? 'none' : 'block';
  targetToggleBtn.textContent = open ? 'Show Answer' : 'Hide Answer';
});

/* Edit Answer (S, C, A) */
[tSph, tCyl].forEach(el => el.addEventListener('input', () => {
  TARGET.S = parseFloat(tSph.value) || 0;
  TARGET.C = parseFloat(tCyl.value) || 0;
  TARGET = clampTarget(TARGET);
  tSph.value = TARGET.S.toFixed(2);
  tCyl.value = TARGET.C.toFixed(2);
  recomputeOver();
}));
tAxis.addEventListener('input', () => {
  TARGET.A = wrapAxis(tAxis.value || 0);
  tAxis.value = TARGET.A;
  recomputeOver();
});

/* quarter-step random (inclusive) between any two bounds */
function randQuarterBetween(a, b){
  const lo = Math.min(a, b), hi = Math.max(a, b);
  const steps = Math.round((hi - lo) / 0.25);
  const n = Math.floor(Math.random() * (steps + 1));
  return +(lo + n * 0.25).toFixed(2);
}

/* New Test: SPH ∈ [+1.00 .. -1.00], CYL ∈ [0 .. -1.00], AXIS ∈ [1..180] */
randBtn.addEventListener('click', () => {
  const randS = randQuarterBetween(+1.00, -1.00);
  const randC = randQuarterBetween(0.00, -1.00);
  const randA = Math.floor(Math.random() * 180) + 1;

  TARGET = clampTarget({ S: randS, C: randC, A: randA });
  tSph.value  = TARGET.S.toFixed(2);
  tCyl.value  = TARGET.C.toFixed(2);
  tAxis.value = TARGET.A;
  recomputeOver();
});

/* Convert Cyl (+↔−) */
formToggleBtn.addEventListener('click', () => {
  const S = parseFloat(sphInput.value) || 0;
  const C = parseFloat(cylInput.value) || 0;
  const A = wrapAxis(axisInput.value || 0);
  sphInput.value  = (S + C).toFixed(2);
  cylInput.value  = (-C).toFixed(2);
  axisInput.value = (wrapAxis(A + 90)) || 180;
  recomputeOver();
});

/* Reset participant Rx */
resetBtn.addEventListener('click', () => {
  sphInput.value  = '0.00';
  cylInput.value  = '0.00';
  axisInput.value = '180';
  recomputeOver();
});

/* Init */
(async function init(){
  await applyLetterImages();
  // keep default TARGET shown in hidden panel
  tSph.value  = TARGET.S.toFixed(2);
  tCyl.value  = TARGET.C.toFixed(2);
  tAxis.value = TARGET.A;
  recomputeOver();
})();
</script>

<div style="height:300px"></div>
</body>
</html>
